import {Map, WeakMap} from '../shared/poorlyfills.js';
import {UIDC, VOID_ELEMENTS} from '../shared/constants.js';
import Updates from '../objects/Updates.js';
import {
  createFragment,
  importNode,
  unique
} from '../shared/utils.js';

import {selfClosing as SC_RE} from '../shared/re.js';

// a weak collection of contexts that
// are already known to hyperHTML
const bewitched = new WeakMap;

// the collection of all template literals
// since these are unique and immutable
// for the whole application life-cycle
const templates = new Map;

// better known as hyper.bind(node), the render is
// the main tag function in charge of fully upgrading
// or simply updating, contexts used as hyperHTML targets.
// The `this` context is either a regular DOM node or a fragment.
function render(template) {
  const wicked = bewitched.get(this);
  if (wicked && wicked.template === unique(template)) {
    update.apply(wicked.updates, arguments);
  } else {
    upgrade.apply(this, arguments);
  }
  return this;
}

// an upgrade is in charge of collecting template info,
// parse it once, if unknown, to map all interpolations
// as single DOM callbacks, relate such template
// to the current context, and render it after cleaning the context up
function upgrade(template) {
  template = unique(template);
  const adopt = render.adopt;
  const info =  templates.get(template) ||
                createTemplate.call(this, template);
  let fragment, updates;
  if (adopt) {
    updates = Updates.create(this, info.paths, adopt);
  } else {
    fragment = importNode(this.ownerDocument, info.fragment);
    updates = Updates.create(fragment, info.paths, adopt);
  }
  bewitched.set(this, {template, updates});
  update.apply(updates, arguments);
  if (!adopt) {
    this.textContent = '';
    this.appendChild(fragment);
  }
}

// an update simply loops over all mapped DOM operations
function update() {
  const length = arguments.length;
  for (let i = 1; i < length; i++) {
    this[i - 1](arguments[i]);
  }
}

// a template can be used to create a document fragment
// aware of all interpolations and with a list
// of paths used to find once those nodes that need updates,
// no matter if these are attributes, text nodes, or regular one
function createTemplate(template) {
  const paths = [];
  const html = template.join(UIDC).replace(SC_RE, SC_PLACE);
  const fragment = createFragment(this, html);
  Updates.find(fragment, paths, template.slice());
  const info = {fragment, paths};
  templates.set(template, info);
  return info;
}

// some node could be special though, like a custom element
// with a self closing tag, which should work through these changes.
const SC_PLACE = ($0, $1, $2) => {
  return VOID_ELEMENTS.test($1) ? $0 : ('<' + $1 + $2 + '></' + $1 + '>');
};

export default render;
